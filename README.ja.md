# nautilus_save_tabs

インストールや使い方は [README.md](README.md) を読んでください。
ここでは、スクリプトの中の重要な部分のアルゴリズムについて解説します。

## 動作原理

Nautilus の script 機能を使います。 xdotool で キー入力をさせてタブを移動し
ながら、各タブの情報を取得します。 Nautilus のキーボード・ショートカットで
使えるものは
* 最初のタブに移動
* 次のタブに移動
* 前のタブに移動

です。
最後のタブに移動するには、最初のタブに移動してから前のタブに移動します。

タブの移動は最後まで行くと最初に戻ってきてしまうので、
いくつタブが開いているかわかりません。

### タブ決定アルゴリズム

[1, 2, 3] という列を先頭から順番に読み取っていって右端に行くと左端に戻る場合、
タブの個数より多く(ここでは5回)読み取ると [1, 2, 3, 1, 2] という列を得ます。
同様に後ろから読み取ると
[3, 2, 1, 3, 2] という列を得ます。

先頭から読んだ列を x、後ろから読んだ列を反転したものを y とします。
```
x = [1, 2, 3, 1, 2]
y = [3, 2, 1, 3, 2].reverse = [2, 3, 1, 2, 3]
```

y を左回りに回転させながら比較していくと、

y -> [3, 1, 2, 3, 2] -> [1, 2, 3, 2, 3]

となり、回転した回数だけ余分なものが右端にたまっていき、余分なものを除いた
部分が x の同じ長さの部分と一致するところが見つかります。このとき、

* この２つの列 x, y の一致している部分が本来のタブの列になる。
* x の余分な部分は、本来のタブの列の先頭に一致する。
* y の余分な部分は、本来のタブの列の末尾に一致する。

が成り立ちます。

y の長さの半分分回転させても上の３条件を満たすことがなかった場合、
読み取り回数がタブの個数よりも少なかったということになります。
読み取り回数を２倍にして再度読み取ります。

### 読み取り回数がタブの個数の２倍以上の場合

```
x = [1, 2, 3, 1, 2, 3, 1, 2]
y = [3, 2, 1, 3, 2, 1, 3, 2].reverse = [2, 3, 1, 2, 3, 1, 2, 3]
```

先ほどと同様に一致する部分を探していくと

`[1, 2, 3, 1, 2, 3]`

が見つかります。この場合、本来のタブの列が複数回現れていますので、１回分を
探す必要があります。

### 複数回の繰り返しから１回分を探すアルゴリズム

1. 1回分の長さは得られた列の長さの約数になっています。  
`[1, 2, 3, 1, 2, 3]` の場合、列の長さは 6 で１回分の長さは 3 です。
6の約数は `1, 2, 3, 6` です。
2. 得られた列を、同じ数ずつになるように分割します。このときの`同じ数`は
上で求めた約数です。小さい方から順番に試します。

  - 1のとき、`[[1], [2], [3], [1], [2], [3]]`
  - 2のとき、`[[1, 2], [3, 1], [2, 3]]`
  - 3のとき、`[[1, 2, 3], [1, 2, 3]]`

3. 分割した列から重複した要素を取り除きます。要素の数が1になっていれば、
そのときの要素が求める1回分です。

  - 1のとき、`[[1], [2], [3]]`
  - 2のとき、`[[1, 2], [3, 1], [2, 3]]`
  - 3のとき、`[[1, 2, 3]]`

  繰り返しが1回だった場合には、列の長さのとき列全体が得られます。

### 既知の問題
  本来のタブが繰り返しになっている場合には 1回分だけが得られてしまいます。
タブ の情報として現在のURIと選択されているURIを取得しています。全て一致して
いる場合は少ないでしょうから、実際に問題になることはあまりないはずです。
